#include <cpen333/process/subprocess.h>
#include <cpen333/process/shared_memory.h>
#include <cpen333/process/mutex.h>
#include "malwareCommon.h"
#include <chrono>
#include <string>
#include <thread>
#include <string>
#include <iostream>

// Usage:
//    malware <name> <index>
// name is any name
// index is 0 or 1
// defaults to name:malware, index:0
int main(int argc, char* argv[]) {

  // extract name and index
  int index = 0;
  std::string name = "malware";
  if (argc > 1) {
    name = argv[1];
  }
  if (argc > 2) {
    index = std::atoi(argv[2]);
  }

  std::cout << name << " " << std::to_string(index)  << " started" << std::endl;

  //========================================================
  // TODO: CREATE AND INITIALIZE SHARED MEMORY
  //========================================================
  
  // Create vector for processes
  
  cpen333::process::shared_object<sharedMemory> malwareMemory(MALWARE_MEMORY_NAME);
  cpen333::process::mutex mutex(MALWARE_MUTEX_NAME);
  
  int oindex = (index+1)%2;  // index of other malware process

  while(true) {
    std::cout << name << " " << std::to_string(index)  << " running" << std::endl;
	
	
    //=======================================================
    // TODO: CHECK IF OTHER PROCESS MISSED CHECK-IN(S)
    //       - LAUNCH IF NOT RESPONDING
    //=======================================================
	
	// Our process has not checked in, restart.
	if(malwareMemory->processFlag == oindex){
		std::vector<std::string> processArguments;
		
		std::cout << "Process: " << oindex << " isn't running; Restarting" << std::endl;
		
		processArguments.push_back("./malware.exe");
		processArguments.push_back("malware");
		processArguments.push_back(std::to_string(oindex));
		processArguments.push_back("true");
		processArguments.push_back("true");		
		
		//Call the process
		cpen333::process::subprocess process(processArguments);
		
	}
	
	// Set the processFlag to my local oindex value.
	std::unique_lock<decltype(mutex)> lock(mutex);
	malwareMemory->processFlag = oindex;
	lock.unlock();
	
    std::this_thread::sleep_for(std::chrono::seconds(10));
	
	
	
	
  }

  return 0;
}